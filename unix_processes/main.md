# なるほどUnixプロセス ― Rubyで学ぶUnixの基礎

## はじめに
*すべてのコードはプロセス上で実行される*  
プログラムは直接カーネルを操作できない。カーネルとのやりとりはすべてシステムコール経由でなければならない。

## プロセスにはIDがある
プロセスの中身とは一切関連づいておらず、単に連番になっている数値のラベルである。
```
$ python
>>> import os
>>> os.getpid()
1229
```

```
$ ps -p 1229
  PID TTY           TIME CMD
 1229 ttys000    0:00.06 python
```

プロセスの現在のpidはグローバル変数$$にも保持されている。bashから叩くと、
```
$ echo $$
1232
```

## プロセスには親がいる
すべてのプロセスには親となるプロセス（親プロセス）がいる。  
たいていの場合、親プロセスはそのプロセスを起動したプロセスとなる。
```
$ python
>>> import os
>>> os.getppid()
1165
```
親はbashのプロセス

## プロセスにはファイルディスクリプタがある
Unixの世界では「すべてがファイルである」（Unix哲学の一つ）  
ファイルシステム上のファイルだけでなく、デバイス、ソケット、パイプなどもファイルとして扱われる。  
実行中のプロセスで何かしらのリソース（デバイス、ソケット、パイプなど）を開くとファイルディスクリプタが割り当てられる。  
* ファイルディスクリプタは関連しないプロセス間では共有されない  
* リソースを閉じるとファイルディスクリプタも閉じられる。  
* リソースを開いたプロセスが終了すると、ファイルディスクリプタも閉じられる。  
```
$ python
>>> file = open('./test.txt')
>>> file.fileno()
3
```
カーネルはこの番号を使ってプロセスが使用しているリソースを追跡する。  
### なぜ3からなのか？
すべてのUnixプロセスには3つの開かれたリソース（標準ストリーム）がついてくる。  
標準入力（STDIN）、標準出力（STDOUT）、標準エラー出力（STDERR）  
```
$ python
>>> import sys
>>> sys.stdin.fileno()
0
>>> sys.stdout.fileno()
1
>>> sys.stderr.fileno()
2
```
ファイルディスクリプタは、  
* ファイルシステム操作  
* ソケットやパイプを使ったネットワークプログラミング  
などの際に重要となる。  

## プロセスにはリソースの制限がある
1プロセスあたりどれくらいのファイルディスクリプタを持てるのか？  
→カーネルによって1プロセスごとにリソースの制限が設定されている。
```
$ python
>>> import resource
>>> soft, hard = resource.getrlimit(resource.RLIMIT_NOFILE)
>>> soft
4864
>>> hard
9223372036854775807
```
ソフトリミットは本当の制約ではなく、リミットを超えると例外が送られるが、必要であればその値を変更できる。  

## プロセスには環境がある
（プロセスは環境変数をもつ）  
環境変数はキーとバリューが対になっており、プロセスで使えるデータを保持する。  
* すべてのプロセスは親プロセスから環境変数を引き継ぐ。  
* 環境変数はプロセスごとに存在し、それぞれのプロセスではグローバルにアクセスできる。  
```
$ export TEST_ENV="TEST"
$ python
>>> import os
>>> os.getenv('TEST_ENV')
'TEST'
```

## プロセスには終了コードがある
すべてのプロセスは、正常終了か異常終了かを示す終了コード値（0〜255）とともに終了する。  
正常終了時には終了コード0を返し、それ以外はエラーを示す。  
```
$ python
>>> exit()  #正常終了（0）の終了コードを返す
```

## プロセスは子プロセスを作れる
* fork(2)システムコールによって、実行中のプロセスから新しいプロセスを生成できる。  
* fork(2)を呼ぶ側のプロセスは「親プロセス」、生成されるプロセスは「子プロセス」となる。  
* 子プロセスは、親プロセスで使われているすべてのメモリのコピーと、親プロセスが開いているファイルディスクリプタを引き継ぐ。  
→２つのプロセスで開いているファイルやソケットなどを共有できる。  
* 子プロセスがコピーしたメモリは、親プロセス側に影響を与えることなく自由に変更ができる。  
fork.py
```python
import os

if os.fork():
    print("Here in the if block")
else:
    print("Here in the else block")
```

```
$ python fork.py
Here in the if block
Here in the else block
```

### Pidがどうなっているか調べてみる  
```python
import os

print("parent process pid: {0}".format(os.getpid()))

if os.fork():
    print("Here in the if block. pid: {0}".format(os.getpid()))
else:
    print("Here in the else block. pid: {0}".format(os.getpid()))
```

```
$ python fork.py
parent process pid: 1992
Here in the if block. pid: 1992
Here in the else block. pid: 1993
```

if句が親プロセスによって実行され、else句が子プロセスによって実行されていることがわかる。  

### もう少し詳細にforkの挙動を追ってみる
```python
import os

print("parent process pid: {0}".format(os.getpid()))
ret = os.fork()

if ret:
    print("----- if block ------")
    print("pid: {0}".format(os.getpid()))
    print("return value: {0}".format(ret))
    print("---------------------")
else:
    print("---- else block -----")
    print("pid: {0}".format(os.getpid()))
    print("return value: {0}".format(ret))
    print("---------------------")
```

```
$ python fork2.py
parent process pid: 2076
----- if block ------
pid: 2076
return value: 2077
---------------------
---- else block -----
pid: 2077
return value: 0
---------------------
```
Forkメソッドの返値は、親プロセス側には「生成した子プロセスのpid」を返し、子プロセス側には「0」を返す。  
Pythonのif文では整数値は真と評価されるため、親プロセスではif句が実行される。  
Pythonのif文では「0」は偽と評価されるため、子プロセスではelse句が実行される。  

## プロセスは優しい
fork(2)によって生成された子プロセスには親プロセスがメモリ上に持つすべての内容のコピーが含まれる。しかし、物理的にすべてのデータをコピーするのはオーバーヘッドが大きいため、これを回避するためにコピーオンライト（CoW）という仕組みが採用されている。  
CoWでは、子プロセス生成時には親と子はメモリ上の同じデータを物理的に共有しており、親か子のいずれかに変更が生じた場合にだけメモリをコピーすることで両者の独立性を保っている。  

## プロセスは待てる
```python
import os
import sys
import time

ret = os.fork()

if not ret:
    time.sleep(5)
    print("Child task is done!")
    sys.exit()

time.sleep(2)
os.wait() #子プロセスの終了を待つ
print("Parent task is done!")
sys.exit()
```

```
$ python fork_wait.py
（5秒後に）
Child task is done!
Parent task is done!
```

`print(os.wait())`は`(2232, 0)`のように子プロセスのpidと終了コードが返ってくる。  
子プロセスのどれか一つが終了するまでの間、親プロセスの実行を待つ。pidを指定して特定のプロセスを待つ方法もある。  
親が子の終了コードを受け取っているので、単純なプロセス間通信ができたことになる。  

## ゾンビプロセス
カーネルは終了したプロセスの情報をキューに入れておくため、親プロセスは子プロセスの終了時点の情報を必ず受け取ることができる。親プロセスが子プロセスの終了ステータスをいつまでも要求しなければ、その情報はカーネルから取り除かれないため、カーネルのリソースを無駄使いしていることになる。  
したがって、もし親プロセスが子プロセスの終了を待たないつもりなら、子プロセスをデタッチしなければならない。  

## プロセスは通信できる
プロセス間通信（IPC: Inter Process Communication）によく使われる方法はパイプとソケット。    
パイプは単方向のデータの流れ。「パイプを開く」とは、プロセスの片方の端を、別のプロセスの片方の端に繋ぐことをいう。  

## デーモンプロセス
デーモンプロセスは、ユーザーに端末から制御されるのではなく、バックグラウンドで 動作するプロセス。デーモンプロセスのよくある例には、Web サーバやデータベース サーバのように、リクエストを捌くためにバックグラウンドで常に動作するプロセスが挙げられる。  
